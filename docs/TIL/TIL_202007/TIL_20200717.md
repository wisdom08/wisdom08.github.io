---
title: TIL_20200717
permalink: /docs/til_20200717
parent: TIL_202007
grand_parent: TIL
has_children: false
nav_order: 9
---

# Facts

- 무인 주차장 시스템 개발 설계를 해봤습니다.
- '처음 해보는 JSP&서블릿 웹프로그래밍' 이라는 책으로 JSP와 서블릿에 대해서 좀 더 깊게 공부 했습니다.

# Feelings

### 무인 주차장 시스템 개발 설계

- 1차 완성 했을 때는 현재는 단기 차량이지만 정기 차량을 등록 희망자를 위한 정기차량시스템 구축이 없어서 그 부분에 대해서 피드백을 받았습니다. 그래서 신분증 인식 후 정기차량 등록 대상을 확인하고 등록할 수 있게끔 만들었습니다. 그리고 2차 완성 했을 때는 입차, 출차의 기능별 분리 그리고 주자창 관리자의 기능과 이용자의 기능 등 기능별 분리가 모호하다는 피드백을 받아서 3차 완성 때는 그 부분을 확실하게 분리해봤습니다. 객체지향이 뭔지 조금 공부해봐서 너무 객체지향을 생각하면서 설계를 하다보니 오히려 더 복잡해지는 느낌이고 쉽지 않았습니다. 처음 설계하는 단계에서는 객체지향을 생각하기보다는 흐름이 가장 중요하다는 것을 느꼈습니다.

### JSP/서블릿

- 현재 주로 공부하고 있는 책인 '자바 웹 프로그래밍 Next Step'에서는 자세히 알려주지 않아서 궁금하고 답답했던 jsp와 서블릿을 쉽게 하나하나 설명해줘서 헷갈렸던 부분이나 그냥 외우고 넘어갔던 부분을 많이 이해할 수 있어서 좋았습니다. 특히 입력스트림과 출력스트림을 표현할 때 클라이언트와 서버의 통로를 튼다는 식으로 표현한 게 너무 기억에 남습니다. 막연했던 스트림 메서드들이 완전히 이해되었습니다. 그래도 '자바 웹 프로그래밍' 책으로 미리 어느정도 공부 했기 때문에 하루만에 빠르게 완독할 수 있었습니다. 너무 어렵거나 이해되지 않는 부분들은 일단은 넘어갔습니다. 내일부터는 다시 '자바 웹 프로그래밍' 책으로 돌아가서 공부 할 계획입니다. 웹 프로그래밍의 전체적인 흐름이 좀 잡히는 기분입니다.

# Finding

## 무인 주차장 시스템 개발 설계

![](/assets/images/design1,2.jpg)
![](/assets/images/design3.jpg)

## 서블릿

- 서블릿은 웹에서 클라이언트로부터 요청받아서 실행되는 자바 프로그램으로서, 주로 서비스 처리를 위한 데이터 준비 작업과 메소드 호출 역할을 한다.
- 서블릿 페이지를 작성할 때 반드시 상속받아야하는 객체는?
  - HttpServlet : 웹상에서 자바 프로그램이 요청되어 실행될 수 있는 조건을 가지고 있는 객체
- 서블릿의 지역변수는 각 요청마다 스레드별로 스택 영역에 할당되어 사용되지만, 멤버변수는 힙 영역에 할당되어 서블릿을 실행하는 여러 스레드에서 공유한다. (참고: 서블릿 메모리모습)

## 요청 정보와 응답 정보

- 클라이언트가 서버에 서비스를 요청했다는 것은 HTTP 요청 정보를 보냈다는 것.
  - 요청정보는 헤더와 몸체로 구성
- 주소 줄에 URL을 입력하면 서비스가 GET방식으로 요청
- GET방식은 서비스 요청 시 전달하는 데이터를 요청정보의 몸체가 아니라, 요청정보의 헤더에 포함해서 넘긴다.
- 따라서 GET방식으로 전달된 요청정보의 몸체에는 어떤 데이터도 없다. 즉 getContentLength() 메소드는 -1을 반환하고 getContentType() 메소드는 null을 반환
- HttpServletRequest와 HttpServletResponse는 클라이언트로부터 서비스 요청이 있을 때마다 생성되며 웹서버가 응답한 후에 삭제된다.
- getWriter()는 클라이언트와 연결된 출력스트림을 생성하여 반환한다.

## 질의 문자열

- 질의문자열은 클라이언트가 웹서버에 서비스를 요청할 때 추가로 전달하는 데이터를 의미

### GET 방식

- 클라이언트가 질의문자열을 GET방식으로 전송하면 서버로 전달되는 질의문자열이 브라우저의 주소줄에 모두 나타난다. 왜냐하면 GET방식은 질의문자열을 요쳥정보 헤더에 포함하여 전달하기 때문이다.
- GET방식은 질의 문자열이 URI에 포함되어 전달하므로 질의문자열들을 인코딩/디코딩하는 추가 작업이 필요 없어서 처리속도 면에서 빠르다는 장점이 있다.
- GET방식은 서버의 데이터를 단순히 가져오는 작업을 수행하기 위한 방식
  - 단순 선택해서 추출하는 작업을 위한 방식
  - 게시판의 글 읽기 작업은 단순히 게시판 DB에서 글을 조회하는 작업이다. 그래서 GET방식

### GET 방식으로 요청되는 상황

- a 태그 클릭하여 요청: a태그는 서버에 다른 서비스를 요청하는 태그
- 브라우저 주소줄에 url을 입력하여 요청하는 경우
- form 태그에서 method 속성을 생략하여 요청하는 경우

### POST 방식

- POST 방식은 질의 문자열이 요청정보의 몸체에 포함된다.
  - <form>태그를 사용해야만 요청할 수 있다.
- POST 방식은 서버의 데이터 값 수정이나 상태변화를 일으키는 작업을 수행하기 위한 방식
  - 게시판에 글을 쓰거나 수정,삭제하는 작업처럼 게시판 DB의 데이터가 수정되는 작업은 POST 방식으로 처리
- 하지만 서버의 데이터를 수정할 때 모두 POST 방식으로 처리하는 것은 올바르지 않다.
  - 게시판에 새글을 쓰는 작업이라면 PUT방식
  - 기존 글을 수정하는 작업이라면 POST 방식
  - 글 삭제 작업이라면 DELETE 방식
- 질의 문자열 추출
  - String getParameter(String name): 질의 문자열로 넘어온 값을 하나씩 추출할 때 사용
    - 질의문자열에서 name이 중복되지 않고 유일하게 하나만 넘어올 때 사용
- 질의 문자열을 name 단위로 추출할 때는 GET방식과 POST방식 모두 HttpServletRequest의 getParameter() 또는 getParameterValues() 메소드를 사용하여 추출하면 된다.
- 질의 문자열 전체를 추출할 때 GET방식에서는 getQueryString()메소드를 사용하지만 POST방식에서는 프로그램 내의 요청정보에서 직접 읽어와야 한다.

  - POST 방식 질의 문자열 전체 추출 방식

  ```java
  ServletInputStream input = req.getInputStream();
  //req.getInputStream();은 요청정보의 몸체와 서블릿 프로그램 간에 연결된
  //입력스트림을 생성하여 반환해주는 메서드

  //ServletInputStream 객체는 입력스트림으로서 요청정보 몸체에 있는 데이터를
  //서블릿 프로그램으로 읽어오기 위해 사용

  int len = req.getContentLength();
  //req.getContentLength()은 요청정보의 몸체에 담겨있는 문자열의 길이를 반환

  byte[] buf = new byte[len];
  //new byte[] 코드는 바이트 배열을 메모리에 생성
  //이때 배열의 개수는 len변수의 값만큼
  //위 코드는 요청 정보 몸체의 길이만큼 byte배열을 생성한 다음,
  //배열의 시작 주솟값을 buf변수에 저장한다.

  input.readLine(buf, 0, len);
  //input.readLine()은 input 입력스트림으로부터 줄 단위로 데이터를 읽어들인다.
  //즉 input 입력스트림에서 readLine()메소드로 한 줄 읽어서
  //buf배열에 저장하는데 배열의 0번지부터 시작해서 len변수에 저장된 길이만큼 저장해라
  //첫 번째 인자 buf는 한 줄 읽어 들인 문자열을 저장한 바이트 배열

  String s = new String(buf);
  //buf배열(바이트배열)의 데이터를 String 타입의 데이터로 새로 생성
  //buf배열을 이용해 새로 생성한 String의 시작주소를 String 타입의 변수 s에 저장

  out.print("전체 문자열 : " + s);
  //String으로 변환한 요청정보 몸체로부터 읽어 들인 문자열(s변수)을 웹브라우저로 출력
  ```

### 한글이 깨지는 이유?

- 문자열을 처리하는 단계마다 한글을 표현하는 문자코드가 다르기 때문
- 깨진 한글을 복원하는 방법은 GET과 POST방식이 다르다

  - GET은 요청정보 헤더의 URI에
  - POST는 요청정보 몸체에 포함되어 전달되기 때문

    ```java
    req.setCharacterEncoding("UTF-8");
    //클라이언트가 보낸 요청정보의 몸체에 있는 문자열들을
    //UTF-8 문자셋을 사용하여 인코딩처리
    ```

### 서블릿 변수

- 서블릿의 멤버 변수는 동일한 서블릿을 실행하는 모든 클라이언트가 공유한다.
- 서브릿의 지역 변수는 각 클라이언트마다 독자적으로 생성하여 사용된다.

```java
out.flush();
// out 출력스트림의 버퍼에 있는 내용을 강제로 전송
// 기본적으로는 버퍼의 크기만큼 내용이 채워졌을 떄 실제 전송이 이루어진다.
// 그런데 위 메소드는 버퍼가 채워졌는지 관계없이 버퍼에 있는 내용 출력
```

## 상태정보 유지 기술

- 클라이언트나 서버에 계속된 요청에서 사용할 수 있도록 저장한 정보들을 상태정보라고 함

### 저장위치 분류

- 클라이언트 측에 저장 기술
  - 웹에서 클라이언트는 웹 브라우저를 의미한다.
  - 쿠키
  - 서블릿에서 쿠키 기능이 있는 객체: javax.servlet.http.Cookie
- 서버 측에 저장 기술
  - 서버의 힙 메모리 영역에 만들어진 객체에 상태정보를 저장(등록)하는 것
  - 서블릿에서 서버 측에 상태정보를 저장할 수 있는 객체
    - javax.servlet.ServletContext
    - javax.servlet.http.HttpSession
    - javax.servlet.http.HttpServletRequest

### RequestDispatcher 요청 재지정

- RequestDispatcher 객체에서 제공하는 요청 재지정 메소드
  - forward(ServletRequest request, ServletResponse response): 요청을 다른 자원으로 넘긴다.
  - include(ServletRequest request, ServletResponse response): 다른 자원의 처리 결과를 현재 페이지에 포함한다.

```java
ServletContext sc = this.getServletContext();
//getServletContext() 메소드를 사용하여 ServletContext 객체의 주솟값을 추출한다.
//ServletContext 객체를 추출하는 이유은 ServletContext에서 제공하는
//RequestDispatcher 객체를 생성하는 메소드를 사용하기 위해서이다.

RequestDispatcher rd = sc.getRequestDispatcher("/dispatcher2");
//ServletContext sc의 getRequestDispatcher() 메소드를 사용해 RequestDispatcher 객체를
//생성한 후 반환받는다. 반환된 rd는 "/dispatcher2"라는 path 값을 가진다.

// *** /dispatcher2 경로를 가지는 ReqeustDispatcher 객체를 생성한 후
//밑에 forward() 메소드를 이용하여 이동시킨다. ***

rd.forward(req,resp);
//RequestDispatcher rd객체가 가지고 있는 path에 해당하는 페이지로 이동한다.
//forward()메소드로 이동하므로 이동한 페이지에서 클라이언트 측으로 응답을 보낸다.
```

### 고급기능: 필터

- 필터는 클라이언트로부터 서블릿이 요청되어 수행될 때 필터링 기능을 제공하기 위한 기술
- JSP(Java Server Pages)는 동적인 웹 콘텐츠를 생성하기 위한 웹애플리케이션 개발 기술

## JSP

### JSP 동작원리

- 응답정보를 만들기 위해 요청을 어떻게 처리할 것인가를 명세한 태그 기반의 문서이다.
- JSP 내에는 템플릿 데이터와 동적인 기능을 담당하는 액션들이 혼합되어 있다.
- 웹 애플리케이션 개념은 서블릿 스펙에서 상속되었다.
- 컨테이너는 JSP와 서블릿 클래스를 웹 컴포넌트로 인식한다.
- 요청된 JSP는 컨테이너에 전달되고 컨테이너는 해당 JSP를 해석하며, 해석된 결과물이 실제 서비스를 제공한다.
- 컴포넌트와 컨테이너를 분리하는 것은 컨테이너가 제공하는 서비스를 통해 컴포넌트의 재사용을 가능하게 해주기 때문이다.

### JSP 스크립트 태그

- <%@ ... %>: 페이지에 대한 정보 설정
- <%! ... %>: 멤버 변수 또는 메소드 선언
- <% ... %>: \_jspService() 내에 그대로 옮겨짐
- <%= ... %>: \_jspService() 내에 그대로 옮겨짐. 단 out.print();으로 변경됨
- <% 실행문 %>

## 웹 애플리케이션 디자인 패턴

### MVC(디자인 패턴)

- 뷰: 클라이언트가 보는 화면으로서 클라이언트로부터 요청이 일어나거나 처리된 결과를 보여주는 페이지
- 컨트롤러: 뷰에서 클라이언트가 서비스를 요청했을 때 실행되는 페이지이다
  - 서비스를 처리하는 메소드를 호출함으로써 클라이언트 요청과 서비스 처리 객체를 연결해주는 중계 역할을 하면서 서비스 처리 흐름을 제어한다.
  - 컨트롤러가 처리하는 기능
    1. 뷰에서 들어온 요청을 받는다
    2. 클라이언트가 전달한 파라미터를 추출한다.
    3. 파라미터의 유효성을 검사한다. 유효성 검사에 실패하면 다시 입력뷰로 이동한다.
    4. 서비스 객체의 메소드를 호출하며 파라미터를 서비스 객체로 전달한다.
    5. 츌력 뷰 페이지로 이동한다.
- 모델: MVC패턴에서 모델은 두 가지로 구분한다.
  1. 서비스 처리를 담당하는 Service 객체
  2. 데이터베이스 처리를 담당하는 DAO 객체

### 3계층 아키텍처(구조적인 측면): 의존성 최소화, 독립성 최대화

- 프레젠테이션 계층: 뷰와 컨트롤러
- 비지니스 계층: 실제 요청된 서비스를 처리하는 비지니스 로직이 구현된 영역
- 영속 계층: 데이터베이스에 대한 처리를 하는 영역

### 프레임워크

- 반제품, 미완성 상태
