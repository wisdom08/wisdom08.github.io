---
title: TIL_20200729
permalink: /docs/til_20200729
parent: TIL_202007
grand_parent: TIL
has_children: false
nav_order: 20
---

# Facts

- 자바웹프로그래밍 책에서 리팩토링 하기 전 코드에서 if-else문이 여러개 반복되고 있었는데 이를 OCP(개방폐쇄의 원칙)을 위반했다고 말해서 왜 위반한건지 궁금해서 이에 대해서 처음 찾아보고 공부를 해봤습니다.
- HTTP 재복습했습니다.

# Feelings

- 처음 자바웹프로그래밍 책을 공부할 때는 자세하기 하나하나 파고들기보다는 전체적으로 흐름을 파악하려고 했습니다. 그리고 지금은 이해 하기 너무 어려운 것은 정보를 찾아보고 공부하면서 책의 진도를 나가고 있습니다. OCP를 처음 공부하고 느낀 것은 IF-ELSE문의 반복을 피할 수 있는 코드를 짜야되겠구나 라는 것을 느꼈습니다.
- HTTP를 공부하면 할수록 헤더에 대한 이해가 중요함을 느낍니다.

# Finding

## OCP(Open Close Principle): 개방 폐쇄의 원칙

- 소프트웨어 구성요소(컴포넌트,클래스,모듈,함수)는 확장에 대해서는 개방돼야 하지만, 변경에 대해서는 폐쇄되어야 한다.
- 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 뜻

### If-else 의 문제점 ⇒ 유지보수가 점점 어려워진다.

- 변경, 확장이 될 수록 코드가 복잡해진다.
- 코드를 수정하거나 수정할 위치를 찾는데 점점 오래 걸린다.
- 실수로 추가하지 않고 누락하는 부분이 생길 가능성이 있다.

### COP 적용방법

1. 상속(is-a)
   - 깨지기 쉬운 상위클래스 문제
     - 상속은 하위클래스가 상위클래스의 기능과 밀접하기 때문에 상위가 바뀌면 하위에 영향이 매우 크다.
2. **컴포지션**(has-a)
   - 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
   - 이 두 모듈이 만나는 지점에 인터페이스를 정의
   - 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성

### OCP 장점

- 기능이 추가, 변경되어도 기존 코드는 변경 되지 않는다.
- 확장이 쉽다.
- 구현체를 주입해서 테스트 가능

### 전략패턴: OCP를 준수하기 위해 여태 한 방식이 전략 패턴

⇒ 기존의 코드 변경없이 행위를 자유롭게 바꿀 수 있게 해주는 OCP를 준수한 디자인 패턴

- 전략: 어떤 목적을 달성하기 위해 일을 수행하는 방식
  - 비니지스 규칙, 문제를 해결하는 알고리즘 등
- 디자인 패턴의 꽃
- 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴
- 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
- 새로운 기능의 추가가 기존의 코드에 영향을 미치지 못하게 하므로 OCP를 만족

1. Context
2. Strategy
3. ConcreateStrategy

---

## HTTP(HyperText Transfer Protocol)

HTTP는 인터넷상에서 클라이언트와 서버가 데이터를 주고 받는 방법이다.

Text Transfer라는 단어가 들어간걸 봐서는 둘이서 문자를 서로 주고 받는 것인데, Hyper가 들어가서 인지 글을 주고 받았지만 엄청난 일들이 이루어진다. HTTP 방식이 없었다면 지금 이렇게 글을 쓰고 조회 할 수 있는 이런 일들이 가능했을까?

**클라이언트**(Client)는 HTTP를 통해 데이터를 서버로 **요청**(Request)하는 요청자이며, 흔히 크롬, IE, FireFox 같은 웹 브라우저가 그 역할을 한다. 응용 프로그램에서는 Http 요청을 위해 사용하는 라이브러리가 그 역할을 한다.

**서버**(Server)는 클라이언트가 요청한 데이터를 제공하는 제공자이며 이미지, HTML 파일처럼 파일을 제공하는 서버, 요청 주소에따라 다른 내용을 제공하는 API서버 등 다양하게 있다. HTTP 통신에서는 서버가 제공하는 결과를 **응답**(Response)이라고 한다.

![](/assets/images/http01.png)

## HTTP 메시지 구조

![](/assets/images/http02.png)

요청 메시지와 응답 메시지 구조 첫 줄을빼고는 구조가 똑같다.

HTTP통신을 위해 생성되는 메시지를 뜯어보면 크게 **Header**와 **Body**로 나눌수 있다.

Header는 General Header, Request header, Response Header, Entity header로 나뉜다.

- General Header : 요청과 응답에서 모두 공통으로 들어가는 Header를 의미한다.주요 정보들로 Date (HTTP 메시지 생성 시간), Connection (서버와 클라이언트의 연결옵션), Via(메시지가 어느 중개자를 거쳐서 왔는지), Transfer-Encoding (메시지에 적용된 인코딩 값) 등등이 있다.
- Request Header : 요청시에만 있는 Header이다.주요 정보들로 Host(서버의 호스트명과 포트), User-Agent (브라우저 및 기기 버전 등 요청자에 관한 정보), Referer(요청을 보낸 URL), Accept(클라이언트가 받을 수 있는 미디어 타입), Accept-Encoding(클라이언트가 받을 수 있는 인코딩), Authorization(서버 인증을 위한 정보) 등등이 있다.
- Response Header : 응답시에만 있는 Header이다.주요 정보들로 Server(서버 어플리케이션 이름과 버전), Age(응답이 캐쉬된 시점부터 얼마나 오래 되었는지), Set-Cookie(서버에서 클라이언트에게 설정한 쿠키정보), Allow(서버측에 요청가능한 HTTP 요청방식) 등등이 있다.
- Entity Header: HTTP메시지의 BODY(본문)에 관한 정보가 있는 Header.주요 정보들로 Content-Encoding(본문에 적용된 인코딩), Content-Length(본문의 크기), Content-Type(본문의 응답이 어떤 타입인지), Content-Location(본문이 실제존재하는 위치), Expires(본문이 캐시되어 유효한 시간), Last-Modified(본문이 마지막으로 갱신된 시간), ETag(본문의 고유 태그, 본문이 수정되면 태그 갱신됨) 등등이 있다.

  > Body는 요청시 전달하는 데이터 내용, 응답시 받는 데이터 내용으로 HTTP 문서 마지막에 들어간다. Body는 요청과 응답에 따라 있을수도 없을수도 있으며 Body가 없으면 Entity Header도 없다.

## HTTP 연결 과정

HTTP 프로토콜 전송 과정을 TCP/IP 4계층 관점(?)에서보면, 먼저 TCP/IP 4계층에서 4계층인 Application Layer에서 HTTP 전송에 필요한 메시지를 작성하고(데이터 만듦), 3계층인 Transport Layer에서 서버와 클라이언트의 연결을 실행하고, 2계층인 Internet Layer에서 데이터를 패킷으로 나누는 과정을 거쳐서, 1계층인 Network Interface Layer를 통해 물리적, 전기적 신호로 변환하여 실질적인 데이터 전송을 하게 된다.

4가지 계층들을 거치면서 이런 일들이 일어난다. (실제 동작이 일어나는 관점??)

1. 브라우저 주소창에 URL을 입력하고 엔터를 친다.
2. 해당 HTTP 요청은 먼저 **DNS**(URL을 통해 서버 IP를 알려주는 역할)서버로 전달된다. 만약 DNS서버에 해당 URL에 대한 IP정보가 없으면 다른 DNS 서버들을 추가로 거쳐서 IP정보를 받게 된다.
3. IP정보를 받게되면 해당 IP주소로 HTTP 요청을 시도한다. (TCP/IP 기반이라 PORT번호도 필요한데 HTTP 통신은 기본적으로 80번 포트를 사용한다.)
4. 신뢰성 보장을 위해 3번의 패킷 교환 과정을 거침. (**3 way handshake**)
5. 클라이언트가 진짜 원하던 요청(?)을 시도함.
6. 서버에서 응답을 제공함.
7. 서버와 클라이언트의 연결을 끊기위해 4번의 패킷 교환 과정을 거침.(**4 way handshake**)
8. 브라우저에 결과를 출력함.

## HTTP통신의 특징

위에서 과정을 봤듯이 **한번 요청 & 응답을 거치면 연결을 끊게된다.** 이전 요청에서 클라이언트가 뭘 했는지 알 수가 없다.(stateless)장점으로 보자면 필요한 순간에만 쓰고 사라지는 깔끔함이라 할 수 있겠고단점으로 보자면 요청을 하는 순간 또 연결을 맺어야 하는 불편함이라 할 수 있을거 같다.

일반적으로 html 파일을 하나 받고나면 추가적으로 css, js, image등 많은 파일을 추가적으로 받게되는데 이를 위해 또 연결을 만들고 끊고 만들고 끊고는 많은 자원을 사용하게 된다. 이를 방지하기위해 일정시간동안 연결을 추가적으로 유지하는 keep-alive 라는 옵션이 있다. 요청시 General Header에 Connection 값을 Keep-Alive로 변경하면 사용 할 수 있다.

## HTTPS

![](/assets/images/http03.png)

HTTP 통신은 앞서 말한것 처럼 HTTP 메시지(텍스트)를 주고 받으며 통신을 한다. 이 메시지에는 보안 장치가 따로 없다. 누군가 악의적인 목적으로 HTTP 메시지를 통신 중간에 가로채서 HTTP 메시지를 볼 수도 있다. **HTTP 메시지는 암호화없이 평문으로 전송되기 때문에 통신을 가로채면 보낸 내용을 쉽게 볼 수 있다.**

만약 회원가입을 하는 경우에 이런 일이 발생하면 개인정보는 바로 노출되게 된다. 이를 보완하기위해 나온것이 HTTPS(**H**yper**T**ext **T**ransfer **P**rotocol over **S**ecure Socket Layer)이다. 약자를 보면 Secure라는 단어가 들어가는데, HTTP의 보안적인 단점을 커버한 HTTP 프로토콜의 강화버전이다.

**결론만 간단하게 말하면 HTTP 메시지가 암호화 되어 통신을 하게 된다.**

## HTTPS통신과정

HTTPS 통신과정을 알기 위해서는 대칭 키,공개 키의 개념을 알아야 한다.

**대칭 키**(Symmetric Key)는 정보를 암호화하고 복호화를 할때 같은 값을 이용하는 경우에 사용되는 키이다.

![](/assets/images/http04.gif)

예를들어 ABCD라는 문자를 1111이라는 값으로 암호화를 하고암호화된 문자를 1111이라는 값으로 풀어서 ABCD를 볼 수 있다면1111이 대칭 키가 되는 것이다.

대칭 키는 암호화, 복호화가 간단한 방법이다. 하지만 대칭 키를 다른 사람이 알게 되면 그 사람도 암호화된 문자를 생성하고 풀 수 있기 때문에 대칭 키가 노출되는 경우에는 보안에 부정적인 영향이 발생 할 수 있다.

**공개 키**(Public Key) 방식은 암호화에 사용하는 키와 복호화에 사용되는 키를 분리하는 것이다.

![](/assets/images/http05.gif)

암호화를 할때는 공개 키를 이용해 암호화를 하고 복호화를 할 때는 **비밀 키**(private key)를 이용한다. 이렇게 되면 공개 키가 노출 되더라도 복호화를 위해 필요한 비밀 키를 모르면 복호화를 할 수가 없다.

공개 키 방식은 대칭 키 방식의 보안 문제를 해결한 방법이지만 컴퓨터 자원이 더 많이 들어가는 단점이 있다.

추가로 **SSL인증서**는 클라이언트가 접속한 서버가 신뢰할수 있는 서버라는걸 입증해 주는 역할을 하고, SSL 통신에 필요한 공개키를 클라이언트에게 제공한다.(서비스 정보 & 공개 키에 관한 내용이 있음.)

**CA**(Certificate Authority)는 SSL인증서를 보증해주는 외부 기관들이다.

HTTPS 통신 과정을 간단히(??) 정리해보면.

1. 서버는 CA기관으로 사이트 정보와 공개 키를 전달함.
2. CA기관에서 해당 사이트를 검증하고 나서 사이트 정보와 공개 키를 인증기관의 개인 키로 암호화 하여 SSL 인증서를 제작함.
3. 해당 사이트에 SSL인증서를 발급 함.
4. CA 기관은 브라우저에게 CA기관의 공개 키를 제공함.
5. 클라이언트가 서버로 접속시, 서버로 random 값과 클라이언트 측에서 사용가능한 암호화 기법을 서버로 전송. (Client Hello)
6. 서버에서 random 값과 서버에서 처리가능한 암호화(동일한 암호화 알고리즘을 사용하기 위해 협상 하는 단계) 기법과 SSL인증서를을 함께 클라이언트에게 전송. (Server Hello)
7. 브라우저에 내장된 CA 리스트 정보로 부터 CA가 제공한 공개 키를 이용해 SSL인증서를 복호화 함. 복호화가 성공한다면 인증된 서버임이 확인되고, 공개 키를 클라이언트가 얻게 됨. 서버는 비밀 키를 가지고 있음.
8. 클라이언트는 클라이언트 측 random 값과 서버로 부터 받은 random 값을이용해서 대칭 키 생성함. 이 대칭 키는 실제 데이터를 주고 받을때 사용됨.
9. 클라이언트는 SSL인증서 안에있는 공개 키를 이용해 생성한 대칭 키를 암호화 시켜 서버로 전송함. 이때 전송된 내용은 암호화 됨.
10. 서버는 대칭 키를 비밀 키를 이용해 복호화함. 이제 클라이언트와 서버 모두 대칭 키를 가지고 있음.(5~10번까지의 과정을 handshake라고 함.)
11. 이후 부터는 클라이언트와 서버는 대칭 키를 이용해 데이터를 암호화, 복호화를 하며 요청과 응답을 처리함.

![](/assets/images/http06.png)

## SSL 프로토콜

![](/assets/images/http07.png)

계층 관점에서 본 SSL

Application Layer에서 HTTP 메시지를 만들고 클라이언트 서버 연결 역할을 하는 Transport Layer를 거치기 전 SSL(Secure Socket Layer)를 거친다. SSL을 거치면서 HTTP 메시지는 암호화, 복호화가 이루어진다.

SSL안에는 4가지 프로토콜이 존재한다.

1. handshake protocol : 위에서 언급한 Https통신을 위해 서버와 클라이언트가 정보를 교환하고 보안 방식을 협의하는 하는 역할이다.
2. change cipher spec protocol : handshake 프로토콜을 통해 협의한 내용이 적용됨을 알려주는 역할이다.
3. alert protocol : 클라이언트와 서버의 통신중 비정상적인 동작이나 에러로 인해 세션이 종료되는 경우 사용된다. 위험 수준을 결정하는 Level field의 값이 1이면 Warnning의 의미로써 통신의 중단은 없다. 값이 2이면 Fatal로 즉시 통신을 종료한다.
4. record protocol : handshake protocol에서 협의한 내용을 적용해서 데이터를 암호화, 복호화하여 다음 layer로 넘겨주는 역할이다.
