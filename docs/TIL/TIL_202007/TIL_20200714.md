---
title: TIL_20200714
permalink: /docs/til_20200714
parent: TIL_202007
grand_parent: TIL
has_children: false
nav_order: 7
---

# Facts

- Bus 토폴로지와 Star 토폴로지를 공부했습니다.
- 객체지향 기본을 이어서 공부했고, 객체지향 설계 5대 원칙, 디자인패턴을 공부했습니다.

# Feelings

- 네트워크 책을 한 번 훑었지만 토폴로지 개념은 처음 보는거라 처음에는 좀 생소했지만, 구글링하고 기록하면서 익숙해졌고 어렵지 않게 느껴졌습니다.
- 객체지향의 기본을 학습할 때까지는 헷갈리는 부분이 정리돼고 가려운 부분을 긁어주는 기분이라 공부하기 너무 재밌었는데 설계 5대 원칙과 디자인 패턴은 너무 어려웠습니다. 처음 보는거라 생소해서 이런 느낌이 드는 것 같습니다. 많이 접하다보면 어려움이 줄어들 것이라고 생각합니다.

# Finding

## 토폴로지

버스 토폴로지와 스타 토폴로지 둘다 중요하다. 큰 차이는 버스 토폴로지는 싱글케이블을 이용한다는 것이다. 그래서 버스 토폴로지는 네트워크상에서 작동시키는데 스타 토폴로지와 비교했을 때 쉬운 편이다. 반대로 스타 토폴로지는 중앙의 허브를 활용한다.

### 토폴로지

토폴로지를 정의하기 전에 네트워크라는 단어가 뭔지 정확하게 알고 시작해야 한다. 네트워크는 서로 정보를 교환 할 수 있게끔, 유선 혹은 무선을 통해 연결된 형태를 말한다. 네트워크 개념에 더해져서 토폴로지는 컴퓨터 네트워크에 참여하는 요소(링크,노드)들의 배치 형태/망구석 방식을 의미한다.

### 버스 토폴로지

![](/assets/images/topology1.png)

가장 흔한 형태의 네트워크 토폴로지이다. 형태 때문에 라인 토폴로지라고도 불리고 위에 그림을 보면 알 수 있듯이 쉽게 설치할 수 있다는 장점을 가지고 있다. 쉽게 설치할 수 있고 단순하기 때문에 작은 구역에서 일반적으로 이용된다. 한 장치에서 네트워크 상으로 실패했을 때, 네트워크의 다른 노드에는 영향을 미치지 않는다. 하지만 케이블이 실패하면 시스템 전체가 꺼져버린다는 큰 단점을 가지고 있다.

### 스타 토폴로지

![](/assets/images/topology2.png)

스타 토폴로지는 중앙에 허브가 있는 네트워크 구성형태이다. 이 점으로 알 수 있는 것이 네트워크에 있는 장치들은 개별적으로 허브와 연결된다는 것이다. 디바이스간에 직접적인 연결이 있을 수 없다. 그래서 유연성이 크다는 장점이 있다. 허브만 잘 작동하면 각각의 디바이스들에 문제가 생기든 마든 네트워크는 잘돌아간다. 그래서 매우 복잡한 구조를 가지고 있음에도 버스토폴로지보다 선호된다.

### 버스 토폴로지와 스타 토폴로지 비교

1. 버스 토폴로지와 스타 토폴로지 두 개에서 차이점을 만드는 가장 큰 것은 허브의 존재 유무다. 허브가 있는 스타 토폴로지는 허브로 데이터를 공유할 수도 있다.
2. 버스 토폴로지는 데이터가 한 장치에서 다른 장치로 직접적으로 바로 전송될 수 없다. 지점을 거치고 거쳐야 한다. 그래서 속도가 좀 느리다. 반면 스타 토폴로지는 원하는 장치로 허브를 통해 바로 전송할 수 있기 때문에 버스 토폴로지보다는 속도가 빠르다.
3. 구조적인 측면에서 버스 토폴로지는 선형적이고 스타 토폴로지는 비선형적이다.
4. 장치가 많든 적든, 버스 토폴로지는 딱 하나의 공통 케이블을 필요로 하고, 일반적으로 스타 토폴로지는 네트워크 상에서 장치의 수와 케이블의 수가 동일하다.
5. 스타 토폴로지는 버스 토폴로지보다 비싸다
6. 버스 토폴로지는 에러가 발생했을 때 선형의 네트워크에 있는 모든 장치들을 체크해야만 한다. 반면 스타 토폴로지는 비교적 쉽다.
7. 버스 토폴로지 신호는 한 장치에서 다른 장치로 **한 방향으로만** 전송되지만 스타 토폴로지는 그렇지 않다.

![](/assets/images/topology3.png)

### 전체적으로 비교를 하고나니 버스 토폴로지는 약간 구닥다리 느낌이고 스타 토폴로지는 신식 느낌이다. 그래도 구닥다리가 더 좋을 때도 있지 않을까라고 생각한다.

### 내가 스타트업 창업을 했을 때 네트워크 구조를 짠다면?

나라면 버스 토폴로지를 이용하겠다. 회사를 운영하는 입장에서 불필요한 지출을 최소화 하는 것이 중요하다고 생각한다. 처음에는 크지 않은 규모이기 때문에 버스 토폴로지가 적절하다고 생각한다. 버스 토폴로지와 비교해서 스타 토폴로지의 장점이 물론 있지만, 설치하기도 복잡하고 비용도 많이 드는 스타토폴로지는 작은 규모의 기업에는 과해보인다. 추후 규모가 커진다면 스타토폴로지로 변경해도 전혀 늦지 않다고 생각한다.

## 객체지향

### 클래스 멤버와 객체 멤버를 구분하는 자바 키워드는 static 이다.

- static 키워드가 붙은 속성을 클래스 멤버 속성이라고 한다.
- static이 안붙은 속성은 객체 멤버 속성이라고 한다.
- main() 메서드를 보면 static 키워드가 항상 붙어있다
  - 클래스 멤버 메서드이기 때문이다.

### 상속과 인터페이스

- 상속: 하위클래스 is a kind of 상위클래스
- 인터페이스: 구현 클래스 is able to 인터페이스

  - 해석: 구현 클래스는 인터페이스 할 수 있다.
  - 무엇을 할 수 있다!
  - 예제: 고래는 헤엄칠 수 있다.

- 상위클래스는 하위클래스에게 물려줄 특성이 많을수록 좋을까? 인터페이스는 구현을 강제할 메서드가 많을수록 좋을까?
  - 상위클래스는 물려줄 특성이 풍성할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다. ⇒ 리스코프 치환 원칙 / 인터페이스 분할 원칙에 따른 이유
- 메모리 구조에서 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.(모든 클래스의 최상의 클래스인 Object 클래스의 인스턴스도 함께 생성된다)

### 다형성: 사용편의성

- 오버라이딩? 오버로딩?
  - ride: 올라타다
  - road: 적재하다
  - 인공위성에서 내려다본다고 가정해보자. 오버라이딩(오토바이에 올올라타기)된 경우는 맨 위에 올라탄 존재만 보인다.
  - 오버로딩(트럭에 적재하기)된 경우는 옆으로 적재된 모든 적재물이 다 보인다.
  - 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다는 사실을 기억하자.

### 캡슐화: 정보 은닉

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
  - 왜? 일관된 형식으로 접근하기 위해서

### 참조 변수의 복사

- Call By Value와 Call By Reference의 차이?
  - 다르다고 이해하기보다는 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 판단하고, 참조변수는 저장하고 있는 값을 주소로 판단한다고 이해하자.
- 기본 자료형 변수는 값을 값 자체로 판단한다.
- 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
- 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다. 즉 가지고 있는 값을 그대로 복사해서 넘겨준다.

## 자바가 확장한 객체 지향

### abstarct 키워드: 추상 메서드와 추상 클래스

- 추상메서드
  - 선언부는 있는데 구현부가 없는 메서드
  - 추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 한다.
  - 추상 메서드 없이도 추상 클래스를 선언할 수는 있다.
- 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉 new를 사용할 수 없다.
- 추상 메서드는 하위 클래스에게 메서드의 구현을 강제한다. 오버라이딩 강제
- 추상 메서드를 포함하는 클래스는 반드시 추상 클래스여야 한다.

### 생성자 ⇒ 객체 생성자 메서드로 기억하자

- 클래스의 인스턴스, 즉 객체를 만들 때마다 new 키워드를 사용한다.
- 객체 생성자 메서드
  - 클래스명();
  - 반환값이 없고 클래스명과 같은 이름을 가진 메서드를 객체를 생성하는 메서드
- 자바가 알아서 인자가 없는 기본 생성자를 자동으로 만들어준다.
- 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.
- 생성자는 개발자가 필요한 만큼 오버로딩해서 만들 수 있다.

### 클래스 생성 시의 실행 볼록, static 블록

### final 키워드(마지막, 최종)

- final 키워드가 나타날 수 있는 곳은?
  - 클래스, 변수, 메서드

### final과 클래스

- 상속을 허락하지 않겠다
- extends 뒤에 적으면 에러 발생

### final과 변수

- 변경 불가능한 상수가 된다.

### final과 메서드

- 재정의, 즉 오버라이딩 금지

### instanceof 연산자

- 인스턴스는 클래스를 통해 만들어진 객체
- instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자다.
  - instanceof 연산자의 결과로 true 또는 false를 반납한다.
  - 사용법: 객체*참조*변수 instanceof 클래스명

### package 키워드: 네임스페이스(이름공간)을 만들어주는 역할

### inferface 키워드와 implements 키워드

- 인터페이스는 public 추상메서드와 public 정적 상수만 가질 수 있다.
  - 인터페이스는 추상메서드와 정적상수만 가질 수 있기에 따로
    - 추상메서드: 몸체가 없는 메서드
    - 메서드에 pbulic과 abstract,
    - 속성에 public, static, final을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.
      - ex. public abstract void sayYes();
      - ex. public static final double PI = 3.14159;
  - 변수에 값을 할당할 수 없다는 것은 상수, 즉 final 변수라는 의미다.
  - 클래스명으로 접근 할 수 있는 속성은 정적 속성이다.
- 자바8부터는 디폴트라고 하는 객체 구상 메서드와 정적 추상 메서드를 지원할 수 있게 언어 스펙 변경(자바에서 람다는 인터페이스를 기초로 하고 있다.)

### this 키워드

- 객체가 자기 자신을 지칭할 때 쓰는 키워드
- "나"라고 하는 대명사와 같은 것
- 내 자리에 있는 볼펜 안쓰고 옆 사무실에 있는 볼펜 쓰고 싶을 때
  - 지역 변수에 저장돼 있는 값이 객체 변수에 저장돼 있는 값을 사용하고 싶은데 지역 변수와 객체 변수의 이름이 같은 경우 this.var 라고 하면 객체 변수 var에 저장한 값을 사용하게 된다.
- 지역변수와 속성(객체변수, 정적변수)의 이름이 같은 경우 지역 변수가 우선한다.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 this를 접두사로 사용한다
- 정적변수와 이름이 같은 지역 변수가 있는 경우 정적변수를 사용하려면 클래스명을 접두사로 사용한다.

### super 키워드

- 단일 상속만을 지원하는 자바에서 super는 바로 위 상위 클래스의 인스턴스를 지칭하는 키워드

## 객체 지향 설계 5원칙 - SOLID

- 응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것

### SRP: 단일 책임 원칙

> "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." -로버트 C.마틴

- 역할(책임)을 분리하라는 것
- 여러 개의 클래스로 분리
  - 남자라는 클래스 하나에서, 남자친구/사원/아들/소대원으로 분리
- 클래스 분할 뿐만 아니라, 속성/메서드/패키지/모듈/컴포넌트/프레임워크 등에도 적용
- 단일 책임 원칙과 객체지향 4대 특성(캡!상추다)과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 추상화이다.
- 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 반드시 단일책임원칙을 고려하는 습관을 들이자

### OCP: 개방 폐쇄 원칙

> "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다 - 로버트 C.마틴

      ⇒ 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야한다.

### LSP: 리스코프 치환 원칙

> "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C.마틴

       ⇒ 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.

- 객체지향의 상속
  - 조직도나 계층도가 아닌 분류도가 돼야 한다.

```java
하위 클래스 is a kind of 상위 클래스
- 하위 분류는 상위 분류의 한 종류다

구현 클래스 is able to 인터페이스
- 구현 분류는 인터페이스 할 수 있어야 한다.

=> 위 두개의 문장대로 구현된 프로그램이라면
이미 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다.
```

- 리스코프치환원칙은 객체지향의 상속 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것

### ISP: 인터페이스 분리 원칙

> "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다."

- 로버트 C.마틴

- 남자 클래스를 토막내는 것이 아니라 역할별 인터페이스로 제한한다.
- SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책
  - 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책
- 인터페이스 최소주의 원칙
  - 상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다.

### DIP: 의존 역전 원칙

> "고차원 모듈은 저차원 모듈에 의존하면 안된다.
> 이 두 모듈은 모두 다른 추상화된 것에 의존해야 한다."
> "추상화된 것은 구체적인 것에 의존하면 안 된다.
> 구체적인 것이 추상화된 것에 의존해야 한다."
> "자주 변경되는 구체 클래스에 의존하지 마라" -로버트 C.마틴

```java
자동차 => 스노우 타이어 (자주 변경되는 구체 클래스에 의존)

자동차 => <interface>  타이어
                     ^   ^   ^
                 스노우 일반 광폭타이어
```

- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것
- 자신보다 변하기 쉬운 것에 의존하지마라!

### 정리: 객체 지향 세계와 SOLID

- SoC(Separation Of Concerns)
  - 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것
  - 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다는 것
  - 관심사가 다르고 변화의 시기가 다르면 분리해야 한다는 것
  - SoC를 적용하면 자연스럽게 SOLID를 극한까지 적용
- SOLID 원칙을 적용하면 소스파일의 개수는 더 많아지는 경향이 있지만 충분히 감수할만함

## 스프링이 사랑한 디자인 패턴

- 객체 지향 특성과 설계 원칙(SOLID) 기반으로 구현
- 스프링 프레임워크: OOP 프레임워크
  - 스프링은 객체 지향의 특성과 설계 원칙을 극한까지 적용한 프레임워크
- 디자인패턴은 객체 지향의 특성 중 상속, 인터페이스, 합성(객체를 속성으로 이용)을 이용

### 어댑터 패턴

- 어댑터를 번역하면 변환기라고 할 수 있다.
- 변환기의 역할은 서로 다른 두 인터페이스 사이에 통신이 가능하게 하는 것
  - 핸드폰과 전원 콘센트 사이에서 둘을 연결해주는 충전기가 변환기의 역할을 수행
- 개방 폐쇄 원칙을 활용한 설계 패턴
- JDBC와 JRE가 어댑터의 역할을 수행
- 합성, 즉 객체를 속성으로 만들어서 참조하는 디자인패턴
  - 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에서 대응하도록 중간에 변환기를 통해 호출하는 패턴

### 프록시 패턴

- 프록시는 대리자, 대변인이라는 뜻을 가진 단어
  - 누군가를 대신해 그 역할을 수행하는 존재
- 실제 서비스 객체가 가진 메서드와 같은 이름의 메서드를 사용하는데 이를 위해 인터페이스 사용
  - 인터페이스를 사용하면 서비스 객체가 들어갈 자리에 대리자 객체를 대신 투입해 클라이언트 쪽에서는 실체 서비스 객체를 통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리할 수도 있다.
- 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴
- 클라이언트가 최종적으로 돌려 받는 반환값을 조작하지 않고 그대로 전달

### 데코레이터 패턴

- 데코레이터는 도장/도배업자를 의미, 장식자라는 뜻을 가진다고 생각하자
- 클라이언트가 받는 반환값에 장식을 더한다.
- 원본에 장식을 더하는 패턴
- 프록시 패턴과 구현 방법이 같다.
- 메서드 호출의 반환값에 변화를 주기 위해 죽안에 장식자를 두는 패턴
- 프록시패턴과 동일하게, OCP/DIP 적용된 설계 패턴

### 싱글턴 패턴

- 오직 인스턴스를 하나만 만들고 그것을 계속해서 재사용
- private 생성자를 갖는다
- 단일 객체 참조 변수를 정적 속성으로 갖는다
- 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getlnstance() 정적 메서드를 갖는다
- 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다

> "클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하는 패턴"

### 템플릿 메서드 패턴

- 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴

### 팩터리 메서드 패턴

- 오버라이드 된 메서드가 객체를 반환하는 패턴

### 전략 패턴

- 구성 요소 3가지
  - 전략 메서드를 가진 전략 객체
  - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
  - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)
- 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴

### 템플릿 콜백 패턴

- 전략 패턴의 변형
- 스프링의 3대 프로그래밍 모델 중 하나인 의존성주입에 사용하는 특별한 형태의 전략 패턴
- 전략패턴과 모든 것이 동일한데 전략을 익명 내부 클래스로 정의해서 사용한다는 특징
- 전략을 익명 내부 클래스로 구현한 전략 패턴
