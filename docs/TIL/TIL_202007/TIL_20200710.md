---
title: TIL_20200710
permalink: /docs/til_20200710
parent: TIL_202007
grand_parent: TIL
has_children: false
nav_order: 3
---

# Facts

- StringBuilder / StringBuffer 클래스 공부하면서 각각 비교해봤고 또 String과도 비교해봤습니다.

- 자바스크립트는 어떻게 동작하는지 공부했습니다.

# Feelings

- 6개월 전에 자바스크립트를 공부하고 다시 공부하는 거라서 처음에는 좀 시간이 많이 지나서 생소하게 느껴지기도 했지만 6개월 전보다 자바스크립트가 어떻게 동작하는지 좀 더 명확하게 이해가 된 느낌이라서 기분이 좋습니다.

- 지금 공부하고 있는 자바웹프로그래밍 NEXT STEP 에서 제공하는 requestHandler 파일에서 저 소스 코드 한 줄을 더 이해하고 싶어서 API문서를 찾아봤는데 조금은 알고 있었던 StringBuffer와 비교할 수 있어서 흥미로웠습니다.

  ```java
  StringBuilder sb = new StringBuilder();
  ```

# Finding

## StringBuilder / StringBuffer 클래스

- String의 단점을 보완한 클래스
- String은 내부의 문자열을 수정할 수 없다.
  - immutable ⇒ cannot be chaned
- Buffer(데이터를 임시로 저장하는 메모리)에 문자열을 저장한다.
- 버퍼 내부에서 추가,수정,삭제 작업을 할 수 있다.

  ### StringBuilder - async

- mutable - can be changed
- 동기화 보장하지 않는다.
- 단일 스레드환경에서 사용

  ```java
  StringBuilder sb = new StringBuilder();
  sb.append("java ");
  sb.append("jiye");
  System.out.println(sb.toString());

  //StringBuillder 객체를 만듦으로써 클래스 안에 기본 배열 공간을 미리 만들어 놓는다
  //append 함수가 호출되면 추가되는
  //문자열을 해당 배열 공간에 바로 추가한다.
  //그때 그때 새로운 문자열을 추가해서 만들어 놓지 않는다.
  //추가를 하다가 배열 공간이 모자르면 그때만 공간을 늘려서 복사해주는 식
  //복사하는 횟수가 현저히 줄어들기 때문에 속도나 공간면에서 효율적
  ```

  ### StringBuffer - synchronized

- mutable - can be changed
- 동기화 보장한다.
- 그래서 StringBuilder보다 속도가 느린 점이 있지만 멀티스레드 환경이라면 동기화를 보장하기 위해 StringBuffer 사용

  ### String과 비교한 Stringbuffer

- Faster
- less Memory Consumption

## 자바스크립트가 어떻게 작동하는지 공부하고 적은 내 생각

![](/assets/images/js1.png)
![](/assets/images/js2.png)

자바스크립트가 어떻게 작동하는지 알고 있다면 많은 문제들이 쉽게 해결될 수도 있다고 한다. 자바스크립트는 싱글스레드 모델이다. 즉 하나의 콜스택을 가지고 있고 스크립트를 위에서 아래로 한 번에 딱 하나 씩만 처리 할 수 있다. 그런데 코드에서 매우 오래 걸리는 함수가 있다고 가정해보자. 그러면 웹 브라우저에서 그 함수가 끝날 때까지 마우스 클릭이나 뒤로가기 등 아무것도 할 수 없을 것이다. 매우 답답한 상황이다. 하지만 분명히 해결 방법이 있으니까 많은 사람들이 자바스크립트를 이용하고 있을 것이다. 우선 정확하게 짚고 넘어가야 할 것이 있다. "자바스크립트"는 한 번에 하나의 일만 처리할 수 있다고 했다. 이 문장은 엄밀하게 따지고 들면 완전히 틀린 문장이다. 정확하게 적으면, "자바스크립트 런타임"이 한 번에 하나의 일만 처리할 수 있다. 저 두 문장의 차이를 정확하게 아는 것이 자바스크립트가 어떻게 작동하는지 아는 것과 연관되어 있다.

"자바스크립트 런타임" 환경은 javascript Engine(memory heap, call stack) + web APIs(DOM,AJAX,Timeout(setTimeout)⇒비동기를 처리 할 수 있게끔 도와주는 장소) + callback Queue(onClick,onLoad,onDone) + event loof 로 구성되고 브라우저의 부분이라고 말할 수 있다. 웹브라우저는 자바스크립트 엔진보다 더 많은 요소들을 가지고 있다. 이게 바로 핵심이다. 단순히 자바스크립트 엔진만을 생각해서는 안된다.

웹브라우저의 부분인 자바스크립트는 웹브라우저에 있는 더 많은 요소들로 인해 싱글스택을 가지고 있고 한 번에 하나의 일만 처리할 수 있음에도 불구하고, 비동기 방식(요청과 결과가 뒤섞여서 복잡하지만, 프로세스가 어느 하나의 작업에 묶여있지 않고 동시에 여러작업을 수행)의 프로그래밍 언어라는 앞뒤가 전혀 맞지 않아 보이는 문장이 성립될 수 있는 것이다.

그 중에서 내가 생각하기에 이벤트루프의 역할이 매우 큰 것처럼 보인다. 이벤트루프는 눈에 보이지는 않지만 매우 바쁘게 움직인다고 한다. 어떤 작동을 하냐면 콜백큐와 콜스택을 쉬지않고 체크한다. 콜스택이 비어있지 않다면 이벤트루프는 콜스택에 아무것도 없을 때까지 기다린다. 그리고 콜스택에 아무것도 없게되면 콜백큐에 있는 함수를 콜스택으로 옮겨준다.

이 동작으로 인해 코드에 setTimeout함수가 있는 경우 처음에 콜스택에 쌓이지만 일정시간 후에 작동하라는 함수이기 때문에 비동기적으로 동작하는 함수이고 setTimeout의 Timer를 브라우저가 제공하는 APIs에 등록한다. 그리고 콜스택(FILO구조)에서는 setTimeout은 사라지고 코드상으로 밑 부분에 다른 코드가 있다면 그 줄이 실행된다. 그 후 APIs에 등록된 타이머가 동작하다가 지정한 일정 시간 후에 큐(FIFO구조)로 전달한다. 이때 콜스택에 아무것도 없을 때 이벤트루프는 타이머를 콜스택으로 날려버리고 실행하게 된다.

"콜백큐에 가지고 있다가 콜스택으로 날려버리는 것" 이 동작 원리로 비동기처리가 끝나게 된다. 비동기와 동기의 차이를 내가 이해한 것으로 간단하게 적으면 동기는 'synchronous' 동시에 일어난다는뜻을 가진 단어이지만 동시에 일어난다고 이해하기보다는 순차적 실행으로 이해하면 쉽다. 그리고 비동기는 한 단어로 적으면 '난장판'인 상황이라고 볼 수 있다.
