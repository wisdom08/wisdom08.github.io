---
title: TIL_20200803
permalink: /docs/til_20200803
parent: TIL_202008
grand_parent: TIL
has_children: false
nav_order: 2
---

# Facts

- UML 실전에서는 이것만 쓴다 라는 책에서 지금 저한테 필요해보이는 부분만 발췌해서 읽었습니다.
- 주차비 정산 프로그램 UML을 그려봤습니다.

# Feelings

- enum을 쓰면 더 의존성이 낮아진다고 해서 enum을 사용해봤는데 책에서 본 것을 적재적소에 잘 사용한 기분이 듭니다.
- timeLogger를 처음에는 timer로 해서 차 한 대 당 스레드가 하나씩 돌아가는 낭비가 너무 심한 작동방식으로 작성했었습니다. 그래서 고민을 해보니 계속 타이머를 잴 필요가 없고, 들어온 시간과 나가는 시간만 있으면 된다는 걸 알게 되었고 timer를 timelogger로 변경했습니다. 책에서 읽었 던 것들이 그래도 조금씩 조금씩 제가 그린 UML에 표현이 되는 것 같아서 뿌듯합니다.

# Finding

## 주차비 무인 정산 시스템에 탑재할 프로그램 UML

얼마 전 그렸던 순서도를 참고해서 UML을 그렸습니다.

![](/assets/images/drawio.jpg)
![](/assets/images/parking02.png)

### 주차장 유스케이스 작성

1. 차량이 진입한다.
2. 입구에서 번호판을 인식한다.
3. 장기 차량이 아닌 경우 단기차량으로 들어오고 요금을 안내해준다.
4. 장기차량인 경우 결제 해당 기간을 안내해준다.
5. 입구 차단기가 열리고 시간을 잰다.
6. 차량을 주차한다.
7. 출구에서 번호판을 인식한다.
8. 요금을 결제한다.
9. 출구에서 차단기가 열린다.

### 설계

1. 클래스 확인
   - 주차비
   - 사용자
   - 단기주차
   - 정기주차
   - 할인
   - 현금결제
   - 카드결제
2. 각 클래스의 역할 책임

- 차량(사용자)
  - 진입한다.
  - 주차한다.
  - 출차한다.
  - 장기차량 등록을 한다.
  - 결제한다.
- 단기주차
  - 요금을 안내해준다.
- 장기주차
  - 요금을 안내해준다.
  - 장기차량 등록대상이 맞는지 신분증 인식을 한다.
  - 단기 주차 차량이 맞는지 결제 기간을 확인한다.
  - 남은 기간을 안내해준다.
- Gate
  - 번호판을 인식한다.
  - 입구 차단기 열어준다
  - 출구 차단기 열어준다
- 결제
  - 할인권을 확인한다.
  - 결제 방법의 종류를 안다
  - 영수증 발급 여부를 확인한다
  - 영수증을 발급해준다.
  - 차비를 확인한다.
  - 이용자가 선택한 결제방법으로 주차비를 결제해준다.

---

## UML 실전에서는 이것만 쓴다

### 다이어그램으로 작업합기

- 반복 다듬기
- 행위 먼저
- 코드를 마음속으로 그려보기
- 동적 시나리오를 먼저 생각해보고 이것들이 어떤 정적구조를 함축하는지 결정하는 전략이 좋다
- UML은 도구일 뿐 그 자체가 목적이 되어서는 안 된다.

### 유스케이스

- 시스템의 동작 하나를 기술한 것
- 유스케이스는 방금 시스템에 특정한 일을 시킨 사용자의 관점에서 작성하며, 사용자가 보낸 자극 '하나'에 대한 반응으로 시스템이 진행하는 '눈에 보이는' 이벤트들의 흐름을 포착한다.
  - 눈에 보이는 이벤트란, 사용자가 볼 수 있는 이벤트를 뜻한다.
  - 오직 사용자가 직접 볼 수 있는 것을 적어 놓는다.
- 유스케이스의 세부사항 가운데 일부는 일이 잘못되는 경우를 고려해야 한다.
  - 이를 대체흐름이라고 하고 구현할 시간이 다가올수록 깊게 생각해야한다.
  - 실패 시나리오 생각하기

### 객체지향 개발의 원칙

- 클래스는 오직 하나만 알아야 한다.
- 오직 하나의 책임만 져야 한다.
- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- 의존 관계 역전 원칙(Dependency Inversion Principle, DIP)
  - 자주 변경되는 concrete class에 의존하지 마라
    - 활발히 개발 중인 컨크리트 클래스나 변할 가능성이 높은 비즈니스 규칙을 담은 클래스가 여기에 속한다.
  - 만약 어떤 클래스에서 상속받아야 한다면, 기반 클래스를 추상클래스로 만들어라
  - 어떤 클래스의 참조를 가져야 한다면, 참조 대상이 되는 클래스를 추상클래스로 만들어라
  - 만약 어떤 어떤 함수를 호출해야 한다면, 호출되는 함수를 추상함수로 만들어라
  - 추상클래스와 인터페이스는 보통 자신에게서 유도된 구체적인 클래스보다 훨씬 덜 변한다.
    - 그러므로 구체적인 것보다는 이런 추상적인 것에 의존하는 편이 낫다.
    - 이 원칙을 지키면 변화가 일어났을 때 시스템에 미치는 영향을 줄일 수 있다.
  - 이 원칙을 지키는지 검사 방법
    - UML 다이어그램의 화살표마다 따라가서 모두 인터페이스나 추상클래스를 가리키는지 확인하면 된다. 만약 컨크리트 클래스에 의존하는데 그 클래스가 자주 변경된다면 DIP를 어기는 것이며, 따라서 시스템도 변화에 민감하게 되어 버릴 것이다.
- 인터페이스 격리 원칙(Interface Segregation Principle, ISP)
  - 사용자에게 딱 필요한 메서드만 있는 인터페이스를 제공해서 필요하지 않은 메서드에서 사용자를 보호하라
  - 이렇게하면 사용자가 관심 없는 메서드에세 생긴 변화에서 사용자를 보호할 수 있다.
  - 그리고 사용자가 자신이 사용하는 객체를 너무 많이 알게 되는 일도 막을 수 있다

> 결론

1.  SRP - 어떤 클래스를 변경해야 할 이유는 오직 하나뿐이어야 한다.
2.  OCP - 클래스를 변경하지 않고도 그 클래스의 환경을 바꿀 수 있어야 한다.
3.  LSP - 유도된 클래스의 메서드를 퇴화시키거나 불법으로 만드는 일을 피하라.
4.  DIP - 자주 변경하는 컨트리크 클래스 대신 인터페이스나 추상 클래스에 의존하라.
5.  SIP - 어떤 객체의 사용자에게 그 사용자한테 필요한 메서드만 있는 인터페이스를 제공하라.
