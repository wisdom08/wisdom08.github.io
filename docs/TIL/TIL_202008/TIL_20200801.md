---
title: TIL_20200801
permalink: /docs/til_20200801
parent: TIL_202008
grand_parent: TIL
has_children: false
nav_order: 0
---

# Facts

- '성공과 실패를 결정하는 1%의 객체지향의 원리' 책을 완독했습니다.
- Head First Object-Oriented Analysis & Design(세상을 설계하는 객체지향 방법론) 책 완독했습니다.
- '성공과 실패를 결정하는 1%의 Java 프로그래밍 원리' 책을 완독했습니다.

# Feelings

- 오늘 객체지향 책 2권, 자바 책 1권 읽었습니다. 며칠 전 쿠폰발급프로그램 UML을 객체지향적으로 업그레이드하고 싶어서 객체지향책을 읽고나면 좋은 UML을 그릴 수 있지 않을까 했는데 적용하는 것이 어렵네요. 감이 안집힙니다. 고민을 좀 많이 해봐야겠습니다.

# Finding

## 성공과 실패를 결정하는 1%의 객체지향의 원리

### 객체지향을 한마디로 표현하면?

- 업무 분석으로부터 요구정의, 설계, 프로그래밍, 개발 프로세스까지를 망라하는 소프트웨어 개발의 종합적인 기술이다.

### 객체지향의 세계

- 객체지향의 세계에서는 미리 모든 행동을 정의한다. 그리고 일절 거부하지 않고 따르는 것을 전제로 한다. 폴리모피즘의 구조도 이를 기초로 하고 있다.
- 인스턴스는 외부로부터의 지시가 없는 한 스스로 움직이는 것이 불가능하므로 사전에 정해진 일을 그대로 따따라하는 것 밖에는 할 수 없다.

### 객체지향 이해하기 위해 필요한 것들

- OOP는 품질좋은 프로그램을 높은 생산성으로 만들기 위한 실천적인 기술이다

### OOP는 불필요한 부분을 생략하고 정리 정돈하는 프로그래밍 기술

- OOP에 있어서 상속은 어느 클래스에서 정의된 공통의 성질(변수 또는 서브루틴)을 다른 클래스에서 중복해서 기술하지 않고 이용 가능한 구조

### 구조적 언어에서 해결되지 않은 2가지 과제

1. 전역변수 문제
2. 빈약한 재사용

### OOP의 3대 요소: 클래스, 폴리모피즘, 상속

- 한 가지 더 중요한 것은 형에 맞춤으로써 편해지는 구조이다.

### 클래스: 모으기, 감추기, 많이 만들기 구조

- 서브루틴과 변수를 모으기
- 클래스의 내부에서만 사용하는 변수와 서브루틴을 감추기
- 하나의 클래스로부터 인스턴스를 많이 만들기
  - 클래스로서 정의하면 실행할 때에 얼마든지 인스턴스를 만드는 것이 가능하다.

### 폴리모피즘: 호출하는 쪽을 공통화한다.

- 공통 메인루틴을 만들기 위한 구조

### 상속: 클래스 정의의 중복을 배제한다.

- 변수와 메소드를 정리한 공통 클래스를 만들어 이 정의를 통째로 빌려 쓰는 것이 가능한 구조

---

## Head First Object-Oriented Analysis & Design

### 문자열 비교 없애기 ⇒ enum

- 열거형 타입
- enum이 좋은 점은 enum을 사용하는 메소드나 클래스가 enum에 정의되어 있는 값을 사용하게 보호한다는 것이다.
  - 그래서 스펠링이 틀리거나 잘못 타이핑한 경우 컴파일러가 이를 찾아준다.
  - 타입의 안전과 값의 안전을 얻는 좋은 방법이다.
- 일련번호처럼 유일한 것은 열거형을 이용할 필요가 없다.
- 기타의 모델명처럼 제한된 수가 아닌 것은 열거형을 쓰기에는 너무 많고, toLowerCase() 메서드 이용한다.

### 캡슐화

- 프로그램 일부의 정보를 다른 부분으로부터 보호하는 것
- 클래스에서 행위를 캡슐화하는 경우, 클래스가 변하지 않고도 행위를 변경할 수 있다.
- 캡슐화의 장점은 프로그램을 쪼개내어 다른 부분의 수정 없이 특정 부분을 변경할 수 있다.
- 일반적으로 변경 가능성이 높은 부분을 그렇지 않은 부분으로부터 분리하여 캡슐화하게 된다.
- 프로그램을 논리적 그룹으로 나눠서 분리시키는 일과도 관련있다.
- 클래스 안의 데이터를 프로그램의 행위로부터 분리하는 것처럼, 기타의 일반적인 속성을 실제 기타 객체로부터 분리시킬 수 있다.
- 그러면 기타 객체가 모든 속성들을 가진 새로운 객체 타입을 가리키는 변수를 가지고 있다.
- 기타 객체로부터 기타 속성을 갭슐화하여 분리된 객체에 넣는 것

### 요구사항

- 하나의 요구사항은 특장 상품이나 서비스가 어떤 것이어야 하는지 또는 무엇을 수행해야 하는지를 자세하게 설명하는 것이다.
  - 좋은 요구사항을 얻는 가장 좋은 방법은 시스템이 무엇을 해야 하는지를 이해하는 것
  - 시스템은 고객의 목적을 맞춰주기 위해 필요한 모든 것
- 요구사항은 항상 변한다. 하지만 유스케이스들이 잘만들어져 있으면, 새로운 요구 사항에 맞추어 소프트웨어를 빠르게 바꿀 수 있다.

### 유스케이스

- 요구사항을 찾아내는 방법
- 각 유스케이스는 특정 목표를 달성하기 위해 시스템이 사용자 또는 다른 시스템과 어떻게 상호작용하는지를 전달하는 하나 이상의 시나리오를 제공한다.
  - 하나의 유스케이스, 세가지 부분
    1. 명확한 가치
    2. 시작과 종료시점
    3. 외부 기동자(Actor)
- 대부분의 경우 시스템이 제대로 동작하기 위해 수행해야 할 단계들을 표시한 리스트
- 첫 단계부터 마지막 단계까지 유스케이스를 거치는 하나의 전체 경로를 시나리오라고 부른다.
- 좋은 유스케이스를 만드는 이유는 좋은 요구 사항을 얻기 위해서이다.
- 유스케이스가 바뀌면 요구사항도 바뀐 것을 의미한다.
- 유스케이스 안의 명사들은 대개 클래스로 바뀐다.
  - 유스케이스 안의 명사들이 시스템의 클래스가 되지 않더라도 유스케이스에서 명사들에 집중
- 유스케이스에서의 동사들은 대개 시스템에서 객체의 메소드이다.

### 추상클래스

- 실제 구현 클래스를 위한 저장 장소이다.
- 추상 클래스는 기능을 정의하고 그 기능은 서브클래스가 구현한다.
- 두 개 이상의 클래스에서 공통된 행동(기능)을 발견 할 때마다, 그 행동을 하나의 클래스로 추상화하여 그 행동(기능)을 재사용하도록 하자

### 객체지향의 원리

- 변화하는 것을 캡슐화하자
- 구현에 의존하기보다는 인터페이스에 의존하도록 코딩하자
- 각 클래스는 변경 요인이 오직 하나이어야 한다.
- 클래스는 행동과 기능에 관한 것이다.
- 클래스는 확장에는 열려있고, 수정에는 닫혀 있어야 한다.(OCP)
- 공통되는 부분을 추출하여 추상화하고 한 곳에 두어 중복 코드를 피하라(DRY원리)
- 시스템의 모든 객체는 하나의 책임만을 가지며, 객체가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다.(SRP)
- 서브 클래스들은 부모 클래스들이 사용되는 곳에 대체될 수 있어야 한다.(LSP)

### 객체들 사이에 변하는 속성들이 있을 때, map같은 콜렉션을 사용해서 속성들을 동적으로 저장하자. 새로운 속성들이 클래스에 추가되어도, 메소드들을 추가하거나, 코드를 변경할 필요가 없다.

### 응집도

- 연결의 정도
- 응집도가 높을수록, 잘 정의되어 있고, 잘 연결되어 있는 것
- 응집된 클래스는 하나의 일을 정말 잘하고 그 외의 일은 하려고 하지도 않는다.
- 높은 응집도 ⇒ 느슨한 결합

---

## '성공과 실패를 결정하는 1%의 Java 프로그래밍 원리'

### 자바란 도대체 뭘까?

- 가상 컴퓨터 명세와 그것을 둘러싼 사회 환경이다
  - 단순 프로그래밍 언어가 아니다. 포괄해서 생각하자
- 세계 최초로 성공한 가상 컴퓨터 명세이다.
  - 자바는 가상 컴퓨터를 실현하는 소프트웨어 자체가 아니라, 그 명세(Specification)이다
- 자바는 '중간 언어'라는 공통 코드로 컴파일해서, JVM이라는 가상 컴퓨터에서 작동시켜 호환성 품질을 일정하게 유지한다는 방법으로 해결
- JVM은 OS도 포함하고 있다.

### 운영체제란 무엇을 위한 것인가?

- 애플리케이션이 하드웨어에 직접 액세스하지 않도록 하기 위해서.

### 객체 지향 프로그래밍 언어의 이점?

- 개발자에게 여러 가지 제한을 걸기 위한 규칙을 강화할 수 있다.

### 다형성? 모두 한통속

- 비슷한 것은 똑같은 것으로 취급하는 기능
