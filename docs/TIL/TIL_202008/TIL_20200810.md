---
title: TIL_20200810
permalink: /docs/til_20200810
parent: TIL_202008
grand_parent: TIL
has_children: false
nav_order: 9
---

# Facts

- 스프링으로 게시판과 간단하게 예제 사이트를 몇 번 만들어보고 스프링의 개념을 익히고 싶어서 도서관에서 스프링 관련 책 4권을 빌려왔습니다. 그리고 이번주는 '스프링 퀵스타트' 책에 있는 개념들을 익히고, 예제들을 단순히 따라쳐보는 게 아니라, 설명명과 코드를 보고나서, 혼자서 쳐보는 형식으로 공부하고 있습니다.

# Feelings

- 처음에 스프링을 공부할 때, 스프링의 코어 개념들이 너무 어렵고 이해되지 않았었는데, 몇 번 게시판을 만들어보고 다시 개념들을 보니까 좀 더 익숙하고 편안한 느낌이 듭니다. 일단 계획은 8월 안에 서블릿 프로젝트 하나 완성하고, 스프링 관련 책 4권을 다 공부하고나서, 스프링 프로젝트도 진행하려고 합니다. 계획대로 잘 진행되길..!!

# Finding

## 서블릿 컨테이너: 서블릿 객체 관리

- Servlet 클래스 객체를 생성하고 운용

### 동작 순서

- 클라이언트의 요청이 들어오는 순간 XML 설정 파일을 참조하여 객체를 생성하고 객체의 생명주기를 관리한다.

1. WEB-INF/web.xml 파일을 로딩하여 구동
2. 브라우저로부터 /hello.do 요청 수신
3. hello.HelloServlet 클래스를 찾아 객체를 생성하고 doGet() 메서드 호출
4. doGet() 메소드 실행 결과를 클라이언트 브라우저로 전송

## 제어의 역행

- 결합도와 관련된 개념
- 객체생성과 의존관계에 대한 코드가 사라져서 결과적으로 낮은 결합도의 컴포넌트 구현
- 결합도란, 하나의 클래스가 다른 클래스와 얼마나 많이 연결되어 있는지를 나타내는 표현

## 스프링 컨테이너의 종류

- BeanFactory와 이를 상속한 ApplicationContext 두 가지 유형의 컨테이너를 제공한다.

### BeanFactory

- 스프링 설정 파일에 등록된 bean 객체를 생성하고 관리하는 가장 기본적인 컨테이너 기능만 제공한다.
- 컨테이너가 구동될 떄 bean 객체를 생성하는 것이 아니라 클라이언트의 요청에 의해서만 bean 객체가 생성되는 지연로딩(lazy loading) 방식을 사용한다.
- 따라서 일반적인 스프링 프로젝트에서는 BeanFactory를 사용할 일은 전혀 없다.

### ApplicaitonContext

- BeanFactory가 제공하는 bean 객체 관리 기능 외에도 트랜잭셕 관리나 메시지 기반의 다국어 처리 등 다양한 기능을 지원한다.
- 컨테이너가 구동되는 시점에 bean 등록된 클래스들을 객체 생성하는 즉시로딩(pre-loading) 방식으로 동작한다.
- 웹 애플리케이션 개발도 지원하므로 대부분 이를 사용한다.
- ApplicationContext의 구현 클래스는 매우 다양하다. 그 중에 두 개의 클래스만 알면 된다
  - GenericXmlApplicationContext: 파일 시스템이나 클래스 경로에 있는 XML 설정 파일을 로딩하여 구동하는 컨테이너
  - XmlWebApplicationContext: 웹 기반의 스프링 애플리케이션을 개발할떄 사용하는 컨테이너

## 스프링 XML 설정

### <beans> 루트 엘리먼트

- 스프링 컨테이너는 <bean> 저장소에 해당하는 XML 설정 파일을 참조하여 <bean>의 생명주기를 관리하고 여러 가지 서비스를 제공한다.

### <import> 엘리먼트

- 분리하여 작성한 설정 파일들을 하나로 통합할 때 사용
- 여러 스프링 설정 파일을 포함함으로써 한 파일에 작성하는 것과 같은 효과를 낸다.

### <bean> 엘리먼트

- 스프링 설정 파일에 클래스를 등록하려면 <bean> 엘리먼트를 사용한다. 이때 id와 class 속성을 사용하는데, id속성은 생략할 수 있지만 class 속성은 필수다.
- 하지만 객체를 요청하려면 이름이 반드시 지정되어야 하고, bean 객체를 위한 이름을 지정할 때 사용하는 속성이 id다.
- id 속성은 컨테이너로부터 <bean>객체를 요청할 때 사용하므로 반드시 스프링 컨테이너가 생성한 개체들 사이에서 유일해야 한다. 그래야 컨테이너가 각 객체를 식별할 수 있다.
- name이 id와 같은 기능을 하는 속성인데 id와 다르게 자바 식별자 작성 규칙을 따르지 않는 문자열도 허용한다.
  - 따라서 특수기호가 포함된 아이디를 지정할 때는 id 대신 name 속성을 쓴다.
  - 물론 name 속성값 역시 전체 스프링 파일 내에서 유일해야 한다.
  - id나 name나 어떤 속성을 사용하든 상관없지만 규칙이 있는 id 속성을 선호하는 것 뿐

### <bean> 엘리먼트 속성

1. init-method 속성

- Servlet 컨테이너는 web.xml 파일에 등록된 Servlet 클래스의 객체를 생성할 때 디폴트 생성자만 인식한다.
  - 따라서 생성자로 Servlet 객체의 멤버변수를 초기화할 수 없다.
  - 그래서 서블릿은 init() 메서드를 재정의(Overriding)하여 멤버변수를 초기화한다.
- 스프링 컨테이너 역시 스프링 설정 파일에 등록된 클래스를 객체 생성할 때 디폴트 생성자를 호출한다.
  - 따라서 객체를 생성한 후에 멤버변수 초기화 작업이 필요하다면, Servlet의 init() 같은 메서드가 필요하다.
  - 이를 위해 <bean> 엘리먼트에 init-method 속성을 지원한다.
  - 스프링 컨테이너는 <bean> 등록된 클래스 객체를 생성한 후에 init-method 속성으로 지정된 initMethod() 메서드를 호출한다. 이 메서드에서 멤버변수에 대한 초기화 작업을 처리.

2. destroy-method 속성

- 컨테이너는 종류되기 직전에 자신이 관리하는 모든 객체를 삭제한다.
- 스프링 컨테이너가 객체를 삭제하기 직전에 호출될 임의의 메소드를 지정할 수 있다.

## 의존성 주입

- 스프링 프레임워크의 가장 중요한 특징은 객체의 생성과 의존 관계를 컨테이너가 자동으로 관리한다는 점이다.
  - 이것이 바로 스프링 ioc(제어의 역행)의 핵심 원리이기도 하다.
  - 스프링은 ioc를 두 가지 형태로 지원한다.
    1. Dependency Lookup: 컨테이너가 애플리케이션 운용에 필요한 객체를 생성하고 클라이언트는 생성한 객체를 검색하여 사용하는 방식(애플리케이션 개발 과정에서는 사용X)
    2. Dependency Injection: 객체 사이의 의존 관계를 스프링 설정 파일에 등록된 정보를 바탕으로 컨테이너가 자동으로 처리해 준다.
       - 컨테이너가 직접 객체들 사이에 의존 관계를 처리하는 것을 의미
       1. setter injection
       2. cunstructor injection
